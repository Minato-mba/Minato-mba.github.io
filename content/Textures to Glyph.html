<!DOCTYPE html>
<html lang="en">

<head>

  <link rel="preload" href="../assets/images/container.png" as="image">
  <link rel="preload" href="../assets/images/cell_image.png" as="image">
  <link rel="preload" href="../assets/images/cell_image_selected.png" as="image">
  <link rel="preload" href="../assets/images/normal_button.png" as="image">
  <link rel="preload" href="../assets/images/normal_button_hover.png" as="image">
  <link rel="preload" href="../assets/images/normal_button_active.png" as="image">
  <link rel="preload" href="../assets/images/TTG.png" as="image">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="17x17" href="../assets/images/grid_logo.png">
  <link rel="apple-touch-icon" sizes="170x170" href="../assets/images/grid_logo_big.png">
  
  <!-- Meta Tags -->
  <meta name="description" content="Textures to Glyph - Convert Minecraft Textures to Glyphs easily.">
  <meta name="keywords" content="Minecraft, Texture, Glyph, Converter, Tool">
  <meta name="author" content="@minato4743">
  <meta name="theme-color" content="#1e1e1f">
  <meta name="apple-mobile-web-app-capable" content="yes">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://minato-mba.github.io/content/Textures%20to%20Glyph.html">
  <meta property="og:title" content="Textures to Glyph - Minecraft Texture Converter">
  <meta property="og:description" content="Convert Minecraft textures to custom glyphs for use in resource packs. Free online tool, no download required.">
  <meta property="og:image" content="https://minato-mba.github.io/assets/images/TTG.png">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://minato-mba.github.io/content/Textures%20to%20Glyph.html">
  <meta name="twitter:title" content="Textures to Glyph - Minecraft Texture Converter">
  <meta name="twitter:description" content="Convert Minecraft textures to custom glyphs for use in resource packs. Free online tool, no download required.">
  <meta name="twitter:image" content="https://minato-mba.github.io/assets/images/TTG_pre.png">

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Textures to Glyph</title>
  <style>
    @font-face {
      font-family: Minecraftia;
      src: url("../assets/fonts/minecraft.otf") format("truetype");
    }

    @font-face {
      font-family: MinecraftTen;
      src: url("../assets/fonts/minecraft-ten.ttf") format("truetype");
    }

    @font-face {
      font-family: ar;
      src: url("../assets/fonts/arPix.ttf") format("truetype");
    }

    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      image-rendering: pixelated;
      font-family: "Minecraftia", sans-serif;
      background-image: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
        url("../assets/images/bedrock.png");
      image-rendering: pixelated;
      background-size: 10rem 10rem;
      background-color: #000000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      animation: moveBackground 100s linear infinite;
      padding: 20px;
      color: #c6c6c6;
      min-height: 100vh;
      overflow-x: hidden;
    }

    @keyframes moveBackground {
      0% {
        background-position: 0 0;
      }

      100% {
        background-position: 100vw 0;
      }
    }

    .main-container {
      width: 100%;
      max-width: 1200px;
      padding: 12px;
      border-image-source: url("../assets/images/container.png");
      border-image-slice: 4 4 4 4 fill;
      border-width: 8px;
      border-style: solid;
      margin-bottom: 20px;
    }

    .title-container {
      text-align: center;
      margin-bottom: 20px;
    }

    .title-image {
      max-width: 60%;
      height: auto;
    }

    .top-controls {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }

    @media (max-width: 768px) {
      .top-controls {
        flex-direction: column;
      }
    }

    .control-group {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-grow: 1;
    }

    .minecraft-button {
      color: #58585a;
      font-family: Minecraftia, sans-serif;
      font-size: 1rem;
      text-align: center;
      padding: 6px 12px;
      cursor: pointer;
      border-image-source: url("../assets/images/normal_button.png");
      border-image-slice: 2 2 4 2 fill;
      border-width: 4px 4px 8px 4px;
      border-style: solid;
      outline: none;
      background: transparent;
    }

    .minecraft-button:hover {
      border-image-source: url("../assets/images/normal_button_hover.png");
    }

    .minecraft-button:active {
      border-image-source: url("../assets/images/normal_button_active.png");
      border-image-slice: 2 fill;
      border-width: 4px;
      margin-top: 4px;
    }

    .minecraft-input {
      color: #c6c6c6;
      font-family: Minecraftia, sans-serif;
      font-size: 1rem;
      padding: 6px;
      border-width: 4px 3px 4px 3px;
      border-image-source: url("../assets/images/input2.png");
      border-image-slice: 2 1 2 1 fill;
      background: transparent;
      outline: none;
      width: 100%;
      box-sizing: border-box;
    }

    .glyph-container {
      position: relative;
      overflow: hidden;
    }

    .glyph-grid {
      display: grid;
      grid-template-columns: repeat(16, 1fr);
      gap: 3px;
      margin-bottom: 20px;
      position: relative;
      padding: 8px;
      border-radius: 4px;
    }

    .glyph-cell {
      position: relative;
      aspect-ratio: 1/1;
      background-color: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 0;
      min-height: 0;
      padding: 2px;
      box-sizing: border-box;
      transition: transform 0.1s ease;
    }

    .glyph-cell:hover {
      transform: scale(1.05);
      background-color: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .glyph-cell.selected {
      background-color: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .glyph-cell img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: pixelated;
      display: block;
      margin: auto;
      z-index: 2;
      position: relative;
    }

    .cell-label {
      position: absolute;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.6);
      z-index: 1;
      text-align: center;
      pointer-events: none;
      text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      padding: 0;
      margin: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: flex-start;
      z-index: 1000;
      padding-top: 5vh;
      overflow-y: auto;
    }

    .modal-content {
      width: 90%;
      max-width: 500px;
      border-image-source: url("../assets/images/container.png");
      border-image-slice: 4 4 4 4 fill;
      border-width: 8px;
      border-style: solid;
      padding: 20px;
      max-height: 85vh;
      overflow-y: auto;
      margin-bottom: 5vh;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .modal-title {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.4rem;
      font-family: MinecraftTen;
      color: #979797;
      text-shadow: 2px 2px 0 black;
    }

    .modal-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .repo-image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
      max-height: 300px;
      overflow-y: auto;
      margin: 15px 0;
      border-radius: 4px;
    }

    .repo-image {
      cursor: pointer;
      aspect-ratio: 1/1;
      border-image-source: url("../assets/images/cell_image.png");
      border-image-slice: 2 2 4 2 fill;
      border-width: 2px 2px 4px 2px;
      border-style: solid;
      padding: 1px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease;
    }

    .repo-image:hover {
      border-image-source: url("../assets/images/cell_image_selected.png");
      transform: scale(1.05);
    }

    .repo-image img {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      display: block;
      margin: auto;
    }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: #1e1e1f;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Minecraftia, sans-serif;
      font-size: 2rem;
      z-index: 9999;
      flex-direction: column;
    }

    #loading-logo {
      width: 50%;
      max-width: 400px;
    }

    #loading-bar {
      margin-top: 40px;
      border: 4px solid #ffffff;
      height: 20px;
      width: 60%;
      box-shadow: inset 0 0 0px 4px #1e1e1f;
    }

    #progress-bar {
      width: 0%;
      box-shadow: inset 0 0 0px 4px #1e1e1f;
      background-color: white;
      height: 100%;
    }

    .search-container {
      width: 100%;
      margin-bottom: 10px;
    }

    #search-box {
      width: 100%;
    }

    @media (max-width: 768px) {
      body {
        padding: 0;
        margin: 0;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      .main-container {
        border-width: 4px;
        padding: 8px;
        margin: 0;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }

      .title-container {
        margin-bottom: 10px;
      }

      .title-image {
        max-width: 70%;
      }

      .top-controls {
        margin-bottom: 10px;
        gap: 6px;
      }

      .control-group {
        flex-direction: column;
        width: 100%;
        gap: 6px;
      }

      .minecraft-button {
        width: 100%;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        margin-bottom: 0;

        border-image-source: url("../assets/images/normal_button.png");
        border-image-slice: 2 2 4 2 fill;
        border-width: 4px 4px 8px 4px;
        border-style: solid;
      }

      .minecraft-button:hover {
        border-image-source: url("../assets/images/normal_button_hover.png");
      }

      .minecraft-button:active {
        border-image-source: url("../assets/images/normal_button_active.png");
        border-image-slice: 2 fill;
        border-width: 4px;
        margin-top: 4px;
      }

      .minecraft-input {
        height: 44px;
        font-size: 1rem;
        padding: 0 12px;
        border-width: 3px 2px 3px 2px;
      }

      .glyph-container {
        padding: 0;
        margin: 0;
        overflow-x: hidden;
        width: 100%;
      }

      .row-labels,
      .column-labels {
        display: none;
      }

      .modal-content {
        width: 95%;
        padding: 10px;
      }

      #loading-logo {
        width: 80%;
      }

      .title-image {
        max-width: 90%;
      }

      .control-group {
        flex-direction: column;
        width: 100%;
      }

      .minecraft-button {
        width: 100%;
        margin-bottom: 5px;
      }

      .glyph-cell {
        min-width: 0;
        min-height: 0;
        padding: 0;
        border-width: 0;
        border-radius: 0;
        touch-action: manipulation;
      }

      .glyph-cell:nth-child(even) {
        background-color: rgba(60, 60, 60, 0.7);
      }

      .glyph-cell:nth-child(odd) {
        background-color: rgba(40, 40, 40, 0.7);
      }

      .glyph-cell .cell-label {
        font-size: 0.6rem;
      }

      .main-container {
        padding: 5px;
        border-width: 5px;
        margin: 0;
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 10px 5px;
      }

      .minecraft-button,
      .minecraft-input {
        font-size: 0.9rem;
        padding: 4px 8px;
      }

      .main-container {
        padding: 8px;
        border-width: 6px;
      }

      .modal-content {
        padding: 8px;
      }

      .modal-overlay {
        padding-top: 5vh;
      }

      .glyph-cell {
        border-width: 1px;
      }
    }

    @media (max-width: 350px) {
      .glyph-grid {
        grid-template-columns: repeat(16, 1fr);
      }

      .glyph-container {
        margin-right: -15px;
      }
    }

    ::-webkit-scrollbar {
      width: 14px;
      height: 14px;
      background-color: #262626;
      border: 2px solid #1a1a1a;
    }

    ::-webkit-scrollbar-track {
      background-color: #262626;
      border: 2px solid #1a1a1a;
    }

    ::-webkit-scrollbar-thumb {
      background-color: #555555;
      border: 2px solid #333333;
      border-radius: 2px;
      background-image: url("../assets/images/bedrock.png");
      background-size: 32px 32px;
      image-rendering: pixelated;
      box-shadow: inset 2px 2px 0px 0px rgba(255, 255, 255, 0.3),
        inset -2px -2px 0px 0px rgba(0, 0, 0, 0.3);
    }

    ::-webkit-scrollbar-thumb:hover {
      background-color: #6a6a6a;
    }

    ::-webkit-scrollbar-thumb:active {
      background-color: #4a4a4a;
    }

    ::-webkit-scrollbar-corner {
      background-color: #262626;
    }

    * {
      scrollbar-width: thin;
      scrollbar-color: #555555 #262626;
    }

    @media (max-width: 768px) {
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-thumb {
        background-size: 24px 24px;
      }
    }

    canvas {
      display: none;
    }

    @media (max-width: 768px) {
      body {
        padding: 0;
        margin: 0;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      .main-container {
        border-width: 4px;
        padding: 8px;
        margin: 0;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }

      .title-container {
        margin-bottom: 10px;
      }

      .title-image {
        max-width: 70%;
      }

      .top-controls {
        margin-bottom: 10px;
        gap: 6px;
      }

      .control-group {
        flex-direction: column;
        width: 100%;
        gap: 6px;
      }

      .minecraft-button {
        width: 100%;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        margin-bottom: 0;

        border-image-source: url("../assets/images/normal_button.png");
        border-image-slice: 2 2 4 2 fill;
        border-width: 4px 4px 8px 4px;
        border-style: solid;
      }

      .minecraft-button:hover {
        border-image-source: url("../assets/images/normal_button_hover.png");
      }

      .minecraft-button:active {
        border-image-source: url("../assets/images/normal_button_active.png");
        border-image-slice: 2 fill;
        border-width: 4px;
        margin-top: 4px;
      }

      .minecraft-input {
        height: 44px;
        font-size: 1rem;
        padding: 0 12px;
        border-width: 3px 2px 3px 2px;
      }

      .glyph-container {
        padding: 0;
        margin: 0;
        overflow-x: hidden;
        width: 100%;
        touch-action: manipulation;
      }

      .glyph-grid {
        display: grid;
        grid-template-columns: repeat(16, 1fr);
        gap: 0;
        padding: 0;
        margin: 0;
        width: 100%;
        box-sizing: border-box;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
      }

      .glyph-cell {
        min-width: 0;
        min-height: 0;
        border: 0;
        padding: 0;
        border-width: 0;
        border-radius: 0;
        touch-action: manipulation;
        position: relative;
      }

      .glyph-cell:active {
        opacity: 0.7;
      }

      .glyph-cell:nth-child(odd) {
        background-color: rgba(40, 40, 40, 0.8);
      }

      .glyph-cell:nth-child(even) {
        background-color: rgba(60, 60, 60, 0.8);
      }

      .glyph-cell .cell-label {
        font-size: 0.6rem;
        opacity: 0.7;
      }

      .modal-overlay {
        padding: 0;
        background-color: rgba(0, 0, 0, 0.85);
        align-items: center;
      }

      .modal-content {
        width: 92%;
        max-width: none;
        margin: 0;
        padding: 15px;
        border-width: 6px;
        max-height: none;
        border-radius: 6px;
        overflow: visible;
      }

      .modal-title {
        font-size: 1.5rem;
        margin-bottom: 15px;
      }

      .modal-buttons {
        gap: 10px;
      }

      .modal-buttons .minecraft-button {
        height: 60px;
        font-size: 1.1rem;
      }

      .search-container {
        margin-bottom: 15px;
      }

      #search-box {
        height: 44px;
      }

      .repo-image-grid {
        grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
        max-height: 45vh;
      }

      .repo-image {
        border-width: 3px 3px 6px 3px;
      }

      #loading {
        background-color: #121212;
      }

      #loading-logo {
        width: 75%;
        max-width: 350px;
      }

      #loading-bar {
        width: 80%;
        height: 24px;
      }

      #percentage {
        font-size: 1.5rem;
        margin-top: 15px;
      }

      .full-screen-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 2000;
        background-color: #121212;
        display: none;
        flex-direction: column;
        padding: 0;
      }

      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px;
        background-color: #1e1e1e;
        border-bottom: 2px solid #333;
      }

      .modal-header h2 {
        margin: 0;
        font-size: 1.3rem;
      }

      .modal-close {
        background: none;
        border: none;
        color: white;
        font-size: 1.5rem;
        cursor: pointer;
      }

      .mobile-bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        display: flex;
        background-color: #1e1e1e;
        border-top: 2px solid #333;
        z-index: 100;
      }

      .nav-button {
        flex: 1;
        padding: 12px 0;
        text-align: center;
        color: white;
        border: none;
        background: none;
        font-family: Minecraftia, sans-serif;
        font-size: 0.8rem;
      }

      .nav-button:active {
        background-color: #333;
      }
    }

    @media (max-width: 480px) {
      .glyph-cell .cell-label {
        font-size: 0.55rem;
      }

      .modal-title {
        font-size: 1.3rem;
      }

      .modal-buttons .minecraft-button {
        height: 55px;
        font-size: 1rem;
      }

      .repo-image-grid {
        grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      }

      .mobile-bottom-nav {
        padding-bottom: env(safe-area-inset-bottom);
      }
    }

    @media (max-width: 350px) {
      .repo-image-grid {
        grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
      }

      .glyph-cell .cell-label {
        font-size: 0.5rem;
      }
    }
  </style>
</head>

<body>

  <div id="loading">
    <img id="loading-logo" src="../assets/images/TTG.png" alt="Textures to Glyph">
    <div id="loading-bar">
      <div id="progress-bar"></div>
    </div>
    <p id="percentage">0%</p>
  </div>

  <div class="main-container">
    <div class="title-container">
      <img class="title-image" src="../assets/images/TTG.png" alt="Textures to Glyph">
    </div>

    <div class="top-controls">
      <div class="control-group">
        <input class="minecraft-input" type="text" id="output-name" value="glyph_E9.png" placeholder="Output file name">
        <button class="minecraft-button" id="generate-button">Download</button>
      </div>
      <div class="control-group">
        <button class="minecraft-button" id="import-button">Import Glyph</button>
        <input type="file" id="import-file" accept="image/png" style="display: none;">
        <button class="minecraft-button" id="clear-button">Clear All</button>
      </div>
    </div>

    <div class="glyph-container">
      <div class="glyph-grid" id="glyph-grid">

      </div>
    </div>
  </div>

  <div class="mobile-bottom-nav" id="mobile-nav" style="display: none;">
    <button class="nav-button" id="mobile-generate">Generate</button>
    <button class="nav-button" id="mobile-import">Import</button>
    <button class="nav-button" id="mobile-clear">Clear All</button>
  </div>

  <div class="modal-overlay" id="cell-modal">
    <div class="modal-content">
      <div class="modal-title">Slot Options</div>
      <div class="modal-buttons">
        <button class="minecraft-button" id="select-vanilla">Use Vanilla Texture</button>
        <button class="minecraft-button" id="upload-custom">Upload Custom Texture</button>
        <button class="minecraft-button" id="copy-symbol">Copy Unicode Symbol</button>
        <button class="minecraft-button" id="clear-cell">Clear Cell</button>
      </div>
      <input type="file" id="custom-image" accept="image/png" style="display: none;">
      <button class="minecraft-button" id="close-modal" style="margin-top: 15px;">Close</button>
    </div>
  </div>

  <div class="modal-overlay" id="vanilla-modal">
    <div class="modal-content">
      <div class="modal-title">Select Vanilla Texture</div>
      <div class="search-container">
        <input class="minecraft-input" type="text" id="search-box" placeholder="Search Textures...">
      </div>
      <div class="repo-image-grid" id="repo-images">

      </div>
      <button class="minecraft-button" id="close-vanilla-modal" style="margin-top: 15px;">Close</button>
    </div>
  </div>

  <canvas id="output-canvas" width="256" height="256"></canvas>

  <script>

    const imageURIs = {};
    const glyphData = new Array(256).fill(null);
    let currentCellIndex = -1;

    const loadingElement = document.getElementById('loading');
    const progressBar = document.getElementById('progress-bar');
    const percentageText = document.getElementById('percentage');
    const glyphGrid = document.getElementById('glyph-grid');
    const cellModal = document.getElementById('cell-modal');
    const vanillaModal = document.getElementById('vanilla-modal');
    const repoImagesContainer = document.getElementById('repo-images');
    const searchBox = document.getElementById('search-box');
    const outputName = document.getElementById('output-name');

    window.onload = () => {
      createGlyphGrid();
      loadVanillaItems();
      setupEventListeners();
      setupMobileUI();
    };

    function createGlyphGrid() {
      for (let i = 0; i < 256; i++) {
        const cell = document.createElement('div');
        cell.classList.add('glyph-cell');
        cell.dataset.index = i;

        const codePoint = 0xE000 + i;
        cell.dataset.codePoint = codePoint;

        const row = Math.floor(i / 16);
        const col = i % 16;
        const coordLabel = document.createElement('span');
        coordLabel.classList.add('cell-label');
        coordLabel.textContent = row.toString(16).toUpperCase() + col.toString(16).toUpperCase();
        cell.appendChild(coordLabel);

        cell.addEventListener('click', () => openCellOptions(i));
        glyphGrid.appendChild(cell);
      }
    }

    async function loadVanillaItems() {
      try {
        let currentRepoVersion = await getLatestRepoVersion();

        let totalResources = 0;
        let processedCount = 0;

        const cachedItems = localStorage.getItem('cachedVanillaItems');
        if (cachedItems) {
          const cachedData = JSON.parse(cachedItems);

          if (cachedData.version === currentRepoVersion) {
            console.log("Loading items from cache (version: " + currentRepoVersion + ")");

            Object.assign(imageURIs, cachedData.items);

            for (const [name, src] of Object.entries(cachedData.items)) {
              addVanillaImageToGrid(name, src);
            }

            setTimeout(() => {
              loadingElement.style.display = 'none';
            }, 300);

            return;
          } else {
            console.log("Cache outdated. Repository version: " + currentRepoVersion + ", cached version: " + cachedData.version);
          }
        }

        console.log("Loading resources from repository");

        const foldersToProcess = [
          "resource_pack/textures/items",
          "resource_pack/textures/blocks"
        ];

        const loadedImages = {};

        while (foldersToProcess.length > 0) {
          const currentFolder = foldersToProcess.shift();

          try {
            const response = await fetch(
              `https://api.github.com/repos/Mojang/bedrock-samples/contents/${currentFolder}`
            );

            if (!response.ok) {
              console.error(`Failed to fetch contents of ${currentFolder}:`, response.status);
              continue;
            }

            const data = await response.json();

            const pngFiles = data.filter(item => item.type === "file" && item.name.endsWith('.png'));
            const subfolders = data.filter(item => item.type === "dir");

            subfolders.forEach(folder => {
              foldersToProcess.push(folder.path);
            });

            totalResources += pngFiles.length;

            const folderPromises = pngFiles.map(async (file) => {
              try {
                const imageUrl = file.download_url;
                const imageBlob = await fetch(imageUrl).then(res => res.blob());

                return new Promise((resolve) => {
                  const reader = new FileReader();
                  reader.onload = () => {
                    const img = new Image();
                    img.onload = () => {

                      if (img.width === 16 && img.height === 16) {

                        const folderPrefix = currentFolder.replace('resource_pack/textures/', '');
                        const displayName = `${folderPrefix}/${file.name}`;

                        loadedImages[displayName] = reader.result;
                      }

                      processedCount++;
                      updateLoadingProgress(processedCount, totalResources);
                      resolve();
                    };
                    img.src = reader.result;
                  };
                  reader.readAsDataURL(imageBlob);
                });
              } catch (error) {
                console.error(`Error loading ${file.name}:`, error);
                processedCount++;
                updateLoadingProgress(processedCount, totalResources);
                return Promise.resolve();
              }
            });

            await Promise.all(folderPromises);

          } catch (error) {
            console.error(`Error processing folder ${currentFolder}:`, error);
            continue;
          }
        }

        Object.assign(imageURIs, loadedImages);

        for (const [name, src] of Object.entries(loadedImages)) {
          addVanillaImageToGrid(name, src);
        }

        const cacheData = {
          version: currentRepoVersion,
          items: { ...imageURIs }
        };

        try {
          localStorage.setItem('cachedVanillaItems', JSON.stringify(cacheData));
          console.log("Cached items with version: " + currentRepoVersion);
        } catch (e) {
          console.warn("Could not cache items in localStorage:", e);
        }

      } catch (error) {
        console.error("Error fetching resources:", error);

        setTimeout(() => {
          loadingElement.style.display = 'none';
        }, 1000);
      }
    }

    async function getLatestRepoVersion() {
      try {

        const releaseUrl = "https://api.github.com/repos/Mojang/bedrock-samples/releases/latest";
        const releaseResponse = await fetch(releaseUrl);

        if (releaseResponse.ok) {
          const releaseData = await releaseResponse.json();
          return releaseData.tag_name;
        }

        const commitsUrl = "https://api.github.com/repos/Mojang/bedrock-samples/commits?per_page=1";
        const commitsResponse = await fetch(commitsUrl);

        if (commitsResponse.ok) {
          const commitsData = await commitsResponse.json();
          if (commitsData.length > 0) {
            return commitsData[0].sha.substring(0, 7);
          }
        }

        return "ts-" + Date.now();
      } catch (error) {
        console.error("Error fetching repository version:", error);
        return "ts-" + Date.now();
      }
    }

    function updateLoadingProgress(current, total) {
      const progress = (current / total) * 100;
      progressBar.style.width = `${progress}%`;
      percentageText.innerText = `${Math.floor(progress)}%`;

      if (current >= total) {
        setTimeout(() => {
          loadingElement.style.display = 'none';
        }, 1000);
      }
    }

    function addVanillaImageToGrid(name, src) {
      const div = document.createElement('div');
      div.classList.add('repo-image');
      div.title = name.replace('.png', '').replaceAll('_', ' ');

      const img = document.createElement('img');
      img.src = src;
      img.alt = name;
      img.loading = 'lazy';

      div.appendChild(img);
      div.addEventListener('click', () => selectVanillaImage(name));
      repoImagesContainer.appendChild(div);
    }

    function setupEventListeners() {

      document.getElementById('close-modal').addEventListener('click', closeAllModals);
      document.getElementById('close-vanilla-modal').addEventListener('click', closeAllModals);

      document.getElementById('select-vanilla').addEventListener('click', openVanillaSelection);
      document.getElementById('upload-custom').addEventListener('click', () => {
        document.getElementById('custom-image').click();
      });
      document.getElementById('copy-symbol').addEventListener('click', copyUnicodeSymbol);
      document.getElementById('clear-cell').addEventListener('click', clearCurrentCell);

      document.getElementById('generate-button').addEventListener('click', generateAndDownload);
      document.getElementById('clear-button').addEventListener('click', clearAllCells);
      document.getElementById('import-button').addEventListener('click', () => {
        document.getElementById('import-file').click();
      });

      document.getElementById('custom-image').addEventListener('change', uploadCustomImage);
      document.getElementById('import-file').addEventListener('change', importGlyph);

      searchBox.addEventListener('input', filterVanillaImages);

      window.addEventListener('click', (e) => {
        if (e.target === cellModal || e.target === vanillaModal) {
          closeAllModals();
        }
      });
    }

    function openCellOptions(index) {
      currentCellIndex = index;
      cellModal.style.display = 'flex';
    }

    function openVanillaSelection() {
      cellModal.style.display = 'none';
      vanillaModal.style.display = 'flex';
      searchBox.value = '';
      filterVanillaImages();
    }

    function closeAllModals() {
      cellModal.style.display = 'none';
      vanillaModal.style.display = 'none';
    }

    function selectVanillaImage(name) {
      if (currentCellIndex >= 0) {
        const cell = document.querySelector(`.glyph-cell[data-index="${currentCellIndex}"]`);

        const newCell = document.createElement('div');
        newCell.classList.add('glyph-cell');
        newCell.dataset.index = currentCellIndex;
        newCell.dataset.codePoint = cell.dataset.codePoint;

        const img = document.createElement('img');
        img.src = imageURIs[name];
        newCell.appendChild(img);

        cell.parentNode.replaceChild(newCell, cell);

        newCell.addEventListener('click', () => openCellOptions(currentCellIndex));

        glyphData[currentCellIndex] = {
          src: imageURIs[name],
          name: name
        };
        closeAllModals();
      }
    }

    function uploadCustomImage(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {

          if (img.width <= 16 && img.height <= 16) {
            applyCustomImage(e.target.result);
          } else {
            alert('Image must be 16x16 pixels or smaller!');
          }
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);

      event.target.value = '';
    }

    function applyCustomImage(src) {
      if (currentCellIndex >= 0) {
        const cell = document.querySelector(`.glyph-cell[data-index="${currentCellIndex}"]`);

        const newCell = document.createElement('div');
        newCell.classList.add('glyph-cell');
        newCell.dataset.index = currentCellIndex;
        newCell.dataset.codePoint = cell.dataset.codePoint;

        const img = document.createElement('img');
        img.src = src;
        newCell.appendChild(img);

        cell.parentNode.replaceChild(newCell, cell);

        newCell.addEventListener('click', () => openCellOptions(currentCellIndex));

        glyphData[currentCellIndex] = {
          src: src,
          name: 'custom'
        };

        closeAllModals();
      }
    }

    function copyUnicodeSymbol() {
      if (currentCellIndex >= 0) {

        const nameWithoutExtension = outputName.value.replace(/\.png$/i, '');
        const prefix = nameWithoutExtension.substring(6).toUpperCase();

        const row = Math.floor(currentCellIndex / 16);
        const col = currentCellIndex % 16;

        const rowHex = row.toString(16).toUpperCase().padStart(2, '0');
        const colHex = col.toString(16).toUpperCase().padStart(2, '0');

        const codePoint = parseInt(prefix + rowHex[1] + colHex[1], 16);
        const symbol = String.fromCodePoint(codePoint);

        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(symbol)
            .then(() => {
              alert('Unicode symbol copied to clipboard: ' + symbol + ' (0x' + codePoint.toString(16).toUpperCase() + ')');
            })
            .catch(err => {
              console.error('Could not copy text: ', err);
              fallbackCopy(symbol);
            });
        } else {
          fallbackCopy(symbol);
        }
        closeAllModals();
      }
    }

    function fallbackCopy(text) {

      const textArea = document.createElement('textarea');
      textArea.value = text;

      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);

      textArea.focus();
      textArea.select();

      let successful = false;
      try {
        successful = document.execCommand('copy');
        if (successful) {
          alert('Unicode symbol copied to clipboard!');
        } else {

          alert('Could not copy automatically. Your symbol is: ' + text);
        }
      } catch (err) {
        console.error('Fallback: Could not copy text: ', err);
        alert('Could not copy automatically. Your symbol is: ' + text);
      }

      document.body.removeChild(textArea);
    }

    function clearCurrentCell() {
      if (currentCellIndex >= 0) {
        console.log("Clearing cell at index:", currentCellIndex);
        const cell = document.querySelector(`.glyph-cell[data-index="${currentCellIndex}"]`);

        if (!cell) {
          console.error("Cell not found for index:", currentCellIndex);
          return;
        }

        const newCell = document.createElement('div');
        newCell.classList.add('glyph-cell');
        newCell.dataset.index = currentCellIndex;
        newCell.dataset.codePoint = cell.dataset.codePoint;

        const row = Math.floor(currentCellIndex / 16);
        const col = currentCellIndex % 16;
        const coordLabel = document.createElement('span');
        coordLabel.classList.add('cell-label');
        coordLabel.textContent = row.toString(16).toUpperCase() + col.toString(16).toUpperCase();
        newCell.appendChild(coordLabel);

        if (cell.parentNode) {
          cell.parentNode.replaceChild(newCell, cell);

          newCell.addEventListener('click', () => openCellOptions(currentCellIndex));

          glyphData[currentCellIndex] = null;

          console.log("Cell cleared successfully");
        } else {
          console.error("Cell has no parent node:", cell);
        }

        closeAllModals();
      } else {
        console.error("No cell selected (currentCellIndex:", currentCellIndex, ")");
      }
    }

    function clearAllCells() {
      if (confirm('Are you sure you want to clear all cells?')) {

        glyphGrid.innerHTML = '';
        createGlyphGrid();

        for (let i = 0; i < 256; i++) {
          glyphData[i] = null;
        }
      }
    }

    function filterVanillaImages() {
      const searchTerm = searchBox.value.toLowerCase();
      const images = repoImagesContainer.querySelectorAll('.repo-image');

      images.forEach(image => {
        const name = image.title.toLowerCase();
        if (name.includes(searchTerm)) {
          image.style.display = 'block';
        } else {
          image.style.display = 'none';
        }
      });
    }

    function generateAndDownload() {
      const canvas = document.getElementById('output-canvas');
      const ctx = canvas.getContext('2d');
      let filename = outputName.value;

      if (!filename.toLowerCase().endsWith('.png')) {
        filename += '.png';
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const drawPromises = [];

      for (let i = 0; i < 256; i++) {
        if (glyphData[i]) {
          const x = (i % 16) * 16;
          const y = Math.floor(i / 16) * 16;

          const drawPromise = new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
              ctx.drawImage(img, x, y, 16, 16);
              resolve();
            };
            img.src = glyphData[i].src;
          });

          drawPromises.push(drawPromise);
        }
      }

      Promise.all(drawPromises).then(() => {
        const link = document.createElement('a');
        link.download = filename;
        link.href = canvas.toDataURL('image/png');
        link.click();
      });
    }

    function importGlyph(event) {
      const file = event.target.files[0];
      if (!file) return;

      const regex = /^glyph_[0-9A-F][0-9A-F]\.png$/i;
      if (regex.test(file.name)) {

        outputName.value = file.name.toUpperCase();
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {

          if (img.width === 256 && img.height === 256) {

            clearAllCells();

            const canvas = document.getElementById('output-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);

            for (let y = 0; y < 16; y++) {
              for (let x = 0; x < 16; x++) {
                const index = y * 16 + x;
                const cellX = x * 16;
                const cellY = y * 16;

                const imageData = ctx.getImageData(cellX, cellY, 16, 16);
                let hasContent = false;

                for (let i = 0; i < imageData.data.length; i += 4) {
                  const r = imageData.data[i];
                  const g = imageData.data[i + 1];
                  const b = imageData.data[i + 2];
                  const a = imageData.data[i + 3];

                  if (a > 0 && !(
                    (r === 204 && g === 204 && b === 204) ||
                    (r === 255 && g === 255 && b === 255)
                  )) {
                    hasContent = true;
                    break;
                  }
                }

                if (hasContent) {

                  const tempCanvas = document.createElement('canvas');
                  tempCanvas.width = 16;
                  tempCanvas.height = 16;
                  const tempCtx = tempCanvas.getContext('2d');
                  tempCtx.putImageData(imageData, 0, 0);

                  const cell = document.querySelector(`.glyph-cell[data-index="${index}"]`);
                  const cellImg = document.createElement('img');
                  cellImg.src = tempCanvas.toDataURL();

                  while (cell.firstChild) {
                    cell.removeChild(cell.firstChild);
                  }

                  cell.appendChild(cellImg);

                  glyphData[index] = {
                    src: tempCanvas.toDataURL(),
                    name: 'imported'
                  };
                }
              }
            }

            alert('Glyph imported successfully!');
          } else {
            alert('Imported image must be 256x256 pixels!');
          }
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);

      event.target.value = '';
    }

    function setupMobileUI() {

      const isMobile = window.matchMedia("(max-width: 768px)").matches;

      if (isMobile) {

        const mobileNav = document.getElementById('mobile-nav');
        mobileNav.style.display = 'flex';

        document.getElementById('mobile-generate').addEventListener('click', generateAndDownload);
        document.getElementById('mobile-import').addEventListener('click', () => {
          document.getElementById('import-file').click();
        });
        document.getElementById('mobile-clear').addEventListener('click', clearAllCells);

        const cells = document.querySelectorAll('.glyph-cell');
        cells.forEach(cell => {
          cell.addEventListener('touchstart', function () {
            this.style.opacity = '0.7';
          });

          cell.addEventListener('touchend', function () {
            this.style.opacity = '1';
          });
        });

        const modals = document.querySelectorAll('.modal-content');
        modals.forEach(modal => {

          let startY;
          modal.addEventListener('touchstart', function (e) {
            startY = e.touches[0].clientY;
          });

          modal.addEventListener('touchmove', function (e) {
            const currentY = e.touches[0].clientY;
            const diff = currentY - startY;

            if (diff > 50) {
              closeAllModals();
            }
          });
        });

        document.body.style.minHeight = window.innerHeight + 'px';

        window.addEventListener('resize', function () {
          document.body.style.minHeight = window.innerHeight + 'px';
        });
      }
    }
  </script>
</body>
</html>